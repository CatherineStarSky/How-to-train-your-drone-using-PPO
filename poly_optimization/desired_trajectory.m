function tau_vec = desired_trajectory(PATH, gamma)

% Original path generated by djikstra has number of waypoints depends on
% the resolution. Optimal path is chosen by discarding some points which
% doesn't intersect with an obstacle by plotting a line between two points
% original_path = path{1};
% optimal_path = optimalPath_sw(map_colli, original_path);
%
% PATH = optimal_path;

% gamma = 50; % penalty on time; bigger the penalty, faster the movement.

% initial guess
% Time intervals are chosen randomly between 1s ~ 3s
tau_vec = rand(1,size(PATH,1)-1)*2+1;
K = length(tau_vec);
% Mapping matrix from p to equality constraint, b
A = A_const_appA(tau_vec);
% Permutation matrix to rearrange b
C = permut_mat(K);
% Cost matrix
Q = Q_const_appA(tau_vec);
% C*A^(-T)*Q*A^(-1)*C^(T) = R
R = comp_R_appA(A,C,Q);
% Known derivatives including position. 
bF = const_bf(PATH);
% Unknown b terms are optimized.
b_sorted = comp_b_sorted(R, bF);
% C*A*P = b_sorted
% P = [p0 p1 ... p8 p9| ... ] where P(t) = p9t^9 + p8t^8 + ... + p0
P = (C*A)\b_sorted;
% Cost
J = costFunc_appA(tau_vec, PATH, gamma);

% time_allocation
epsilon_t = 1e-4; % epsilon for numerical gradient

count = 1;
% while count ~= 0
    disp('time allocation started...')
    J_grad = gradient_J(tau_vec, PATH, gamma, epsilon_t);
    i = 1;
    J_seq = [];
while 1
    J_grad = gradient_J(tau_vec, PATH, gamma, epsilon_t);
    alpha = .000001;
    step = 2;
    J_test = [];
    for m=1:100
        tau_vec_test = tau_vec - J_grad/norm(J_grad)*alpha*step^(m-1);
        if find(tau_vec_test<0)
            disp('tau vector cannot have negative values.')
            break
        end
        J_test = [J_test costFunc_appA(tau_vec_test, PATH, gamma)];
        
        % If the latest cost is larger then previous one, escape the loop
        [~, minidx] = min(J_test);
        if minidx ~= length(J_test)
            break
        end
    end
    [minval, minidx] = min(J_test);
    % update tau
    tau_vec = tau_vec - J_grad/norm(J_grad)*alpha*step^(minidx-1);
    % If cost does not change more than 1% for 5 times, we assume it
    % reaches to the minimum.
    J_seq = [J_seq minval];
    i = i+1;
    if i == 5
        if ~any(abs(J_seq - J_seq(end))./J_seq(end) > .01)
            break
        end
        i = 1;
        J_seq = [];
    end
end
disp('time allocation done')

% update polynomial coefficients
A = A_const_appA(tau_vec);
C = permut_mat(length(tau_vec));
bF = const_bf(PATH);
Q = Q_const_appA(tau_vec);
R = comp_R_appA(A,C,Q);
b_sorted = comp_b_sorted(R, bF);
P = (C*A)\b_sorted;

% % Check collision
% X_test = [];
% PATH_test = PATH;
%  count = 0;
% for i=1:length(tau_vec) % # of segments
%     for ii = 1:size(PATH,2) % x,y,z
%         X_test(:,ii) = polyval(P(10*i:-1:10*(i-1)+1,ii),linspace(0,tau_vec(i),50));
%     end
%     if any(collide(map_colli, X_test(2:end-1,:)))
%         %K
%         disp('collision detected')
%         interm_pt = (PATH_test(i+count,:) + PATH_test(i+count+1,:))./2;
%         int2end_path = [interm_pt; PATH_test(i+count+1:end,:)];
%         optimal_int2end = optimalPath_sw(map_colli, int2end_path);
%         %PATH_test = [PATH_test(1:i+count,:); interm_pt; PATH_test(i+count+1:end,:)];
%         PATH_test = [PATH_test(1:i+count,:); optimal_int2end];
%         count = count+1;
%         tau_vec = [tau_vec(1:i-1), rand(1,size(PATH_test,1)-1-(i-1))*2+1];
%         PATH = PATH_test;
%         disp('New path made')
%         K = length(tau_vec);
%         break
%     end
% end

% end
disp('collision free trajectory made')
disp('Finished')
%toc
disp('Cost:')
J = costFunc_appA(tau_vec, PATH, gamma);

% Check trajectory
K = length(tau_vec);
ttt = [];
ttt = [ttt, linspace(0,tau_vec(1),50)];
for i=2:K
    ttt = [ttt, sum(tau_vec(1:i-1)) + linspace(0,tau_vec(i),50)];
end
X = [];
XX = [];
for i=1:length(tau_vec) % # of segments
    for ii = 1:size(PATH,2)
        X(:,ii) = polyval(P(10*i:-1:10*(i-1)+1,ii),linspace(0,tau_vec(i),50));
    end
    XX = [XX;X];
    if size(PATH,2) == 3
        plot3(X(:,1),X(:,2),X(:,3),'LineWidth',1.5)
        hold on
        grid on
        axis equal
    end
end
hold off
end

